# 監査ログの保存は API 内で同期追記し、変更ごとに複数ログを残す

## Context

- 監査ログはフェーズ1から必須であり、API が唯一の更新窓口である。
- 監査ログは SettingsAuditLog として定義済みで、before/after は変更部分のみを保持する設計である。
- 保存対象は更新系 API に限り、GET/閲覧は対象外とする。
- サーバー設定など複数項目の同時更新があり得るため、複数変更の記録方式を決める必要がある。

## Decision

- 監査ログは API 内で同期的に追記する。追記失敗時は更新処理を失敗として扱う。
- 保存対象は更新系 API のみとし、GET/閲覧は対象外とする。
- before/after は変更された部分のみを記録する。
- 複数項目の同時更新は「変更ごとに 1 ログ」を残す。
- 同一リクエスト内で生成される複数ログは createdAt を同一にする。
- 同一リクエスト内の複数ログは entityId を同一にする。
- 同一リクエスト内の複数ログの並び順は path の辞書順で安定化させる。

## Consequences

### 利点

- 監査ログの完全性が高く、更新と監査が一貫する。
- 変更単位で記録されるため、表示・検索が単純になる。
- 同一リクエストの変更を同一時刻で束ねやすい。

### 欠点

- 監査ログ追記失敗で更新が失敗するため、可用性に影響する。
- 同一時刻のログが複数並ぶため、並び順の安定化が必要になる。

### 今後の影響

- ログ規模や負荷が増えた場合、非同期化やバッファリングを再検討する。
- 変更が増えた場合、ログ件数が増加するため保管方針が必要になる。

## Alternatives

- 追記失敗時は更新を成功扱いにする（監査ログはベストエフォート）。
- 非同期化（内部キューやバッファで後続追記）。
- 複数項目更新を 1 ログに集約する。
